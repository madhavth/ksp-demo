//package com.aniket.myevent.processor
//
//import com.aniket.myevent.annotations.Calculator
//import com.aniket.myevent.annotations.CalculatorFunction
//import com.aniket.myevent.annotations.EnumTest
//import com.google.devtools.ksp.processing.CodeGenerator
//import com.google.devtools.ksp.processing.KSPLogger
//import com.google.devtools.ksp.processing.Resolver
//import com.google.devtools.ksp.processing.SymbolProcessor
//import com.google.devtools.ksp.symbol.KSAnnotated
//import com.aniket.myevent.annotations.TestRecord
//import com.google.devtools.ksp.processing.Dependencies
//import com.google.devtools.ksp.symbol.KSClassDeclaration
//import com.google.devtools.ksp.symbol.KSType
//import com.google.devtools.ksp.symbol.KSVisitorVoid
//import com.google.devtools.ksp.validate
//import com.squareup.kotlinpoet.AnnotationSpec
//import com.squareup.kotlinpoet.ClassName
//import com.squareup.kotlinpoet.CodeBlock
//import com.squareup.kotlinpoet.DelicateKotlinPoetApi
//import com.squareup.kotlinpoet.FileSpec
//import com.squareup.kotlinpoet.FunSpec
//import com.squareup.kotlinpoet.INT
//import com.squareup.kotlinpoet.KModifier
//import com.squareup.kotlinpoet.LambdaTypeName
//import com.squareup.kotlinpoet.ParameterSpec
//import com.squareup.kotlinpoet.ParameterizedTypeName
//import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
//import com.squareup.kotlinpoet.PropertySpec
//import com.squareup.kotlinpoet.TypeAliasSpec
//import com.squareup.kotlinpoet.TypeName
//import com.squareup.kotlinpoet.TypeSpec
//import com.squareup.kotlinpoet.TypeVariableName
//import com.squareup.kotlinpoet.asTypeName
//import com.squareup.kotlinpoet.jvm.jvmInline
//import com.squareup.kotlinpoet.jvm.jvmMultifileClass
//import java.io.FileOutputStream
//import java.io.OutputStream
//import java.lang.reflect.Type
//import java.lang.reflect.TypeVariable
//import javax.lang.model.type.TypeKind
//import kotlin.reflect.KClass
//import kotlin.reflect.KType
//import kotlin.reflect.KTypeParameter
//
//
//@OptIn(DelicateKotlinPoetApi::class)
//class TestRecordProcessor(
//    options: Map<String, String>,
//    val logger: KSPLogger,
//    val codeGenerator: CodeGenerator
//) : SymbolProcessor {
//    override fun process(resolver: Resolver): List<KSAnnotated> {
//        val symbols = resolver
//            .getSymbolsWithAnnotation(TestRecord::class.qualifiedName!!)
//        val unableToProcess = symbols.filterNot { it.validate() }
//
//        val dependencies = Dependencies(
//            aggregating = false,
//            *resolver.getAllFiles().toList().toTypedArray()
//        )
//
//        symbols.filter { it is KSClassDeclaration && it.validate() }
//            .forEach {
//                it.accept(TestRecordVisitor(dependencies), Unit)
//            }
//        return unableToProcess.toList()
//    }
//
//    private inner class TestRecordVisitor(val dependencies: Dependencies) : KSVisitorVoid() {
//        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
//            super.visitClassDeclaration(classDeclaration, data)
//
//            val packageName = classDeclaration.packageName.asString()
//            val simpleName = classDeclaration.simpleName.getShortName()
//
//            try {
//                val outputStream = codeGenerator.createNewFile(
//                    dependencies = dependencies,
//                    packageName = packageName,
//                    fileName = "ExtensionSame",
//                )
//                appendToFile(outputStream, simpleName, classDeclaration, packageName)
//            } catch (e: Exception) {
//                if (e is FileAlreadyExistsException) {
//                    val outputStream = FileOutputStream(e.file, true)
//                    appendToFile(outputStream, simpleName, classDeclaration,"")
//                    return
//                }
//                logger.error("exception occcurred $e")
//            }
//        }
//    }
//
//    fun appendToFile(outputStream: OutputStream, simpleName: String, classDeclaration: KSClassDeclaration, packageName: String) {
//        val name = "${simpleName}Extension"
//
//        val addAbstract = FunSpec.builder("add")
//            .addParameter("a", Int::class)
//            .addParameter(ParameterSpec.builder(
//                "b", Int::class
//            ).addAnnotation(ClassName.bestGuess("TestingAutoGenerated"))
//                .build())
//            .returns(Int::class)
//            .addModifiers(KModifier.ABSTRACT)
//            .build()
//
//
//        val subtractAbstract = FunSpec.builder("subtract")
//            .addParameter("a", Int::class)
//            .addParameter("b", Int::class)
//            .returns(Int::class)
//            .addModifiers(KModifier.ABSTRACT)
//            .build()
//
//
//        val entireInterface = TypeSpec.interfaceBuilder(
//            name + "CallBack"
//        ).addFunction(subtractAbstract)
//            .addFunction(addAbstract)
//            .build()
//
//
//        val addFunction = FunSpec.builder("add")
//            .returns(Int::class)
//            .addModifiers(KModifier.OVERRIDE)
//            .addParameter("a", Int::class)
//            .addParameter("b", Int::class.java)
//            .addStatement("return a + b")
//            .build()
//
//
//        val subtractFunction = FunSpec.builder("subtract")
//            .returns(Int::class)
//            .addModifiers(KModifier.OVERRIDE)
//            .addAnnotation(CalculatorFunction::class)
//            .addParameter("a", Int::class)
//            .addParameter("b", Int::class)
////            .addParameter(ParameterSpec.builder("a", Int::class)
////                .addAnnotation(ClassName(""))
////                .build()
////            )
//            .addCode(CodeBlock.of("""
//                val list = listOf<String>()
//                val testing = "1234"
//
//            """.trimIndent()))
//            .addComment("returning a minus b")
//            .addStatement("return a - b")
//            .build()
//
//        val myCompanionObject = TypeSpec.companionObjectBuilder("MyCompanionObject")
//            .build()
//
//
//        val testParam = FunSpec.constructorBuilder()
////            .addParameter(ParameterSpec.builder(
////                "test", Int::class
////            )
////                .defaultValue("300")
////                .addKdoc(CodeBlock.of("val"))
////                .build()
////            )
//            .build()
//
//        val autoAnnotation = TypeSpec.annotationBuilder("TestingAutoGenerated")
//            .build()
//
//
//        val myCustomAnnotation = AnnotationSpec.builder(
//            ClassName.bestGuess("TestingAutoGenerated")
//        ).build()
//
//
//        val listOfString = MutableList::class.parameterizedBy(String::class)
//
//        val enumForTestingClass = EnumTest::class.java
//        val values = enumForTestingClass.enumConstants.map {
//            it.name
//        }
//
//        val generatedStatement = values.map {
//            "EnumTest.$it -> { \"modified $it\" }"
//        }.joinToString("\n\t ")
//
//        val functionReturnRecord = FunSpec.builder("recordToString")
//            .addParameter("record",EnumTest::class)
//            .addModifiers(KModifier.PRIVATE)
//            .addCode(CodeBlock.of("""
//                |return when(record) {
//                |   // iterate through all the values of enumForTestingRecord
//                |   //  $values
//                |   $generatedStatement
//                |}
//            """.trimMargin()))
//            .returns(String::class)
//            .build()
//
//
//        val entireClass = TypeSpec.classBuilder(name)
//            .addAnnotation(Calculator::class.java)
//            .addFunction(addFunction)
//            .addModifiers(KModifier.OPEN)
//            .addFunction(functionReturnRecord)
//            .addFunction(FunSpec.constructorBuilder()
//                .addParameter(ParameterSpec.builder("test", Int::class)
//                    .defaultValue("300")
//                    .build())
//                .addParameter(ParameterSpec.builder("_lambda", LambdaTypeName.get(
//                    null,
//                    listOf(),
//                    ClassName("", name)
//                        )
//                ).build())
//                .addStatement("val test2 = test * 200")
//                .addStatement("println(test2)")
//                .build())
//            .addSuperinterface(ClassName.bestGuess("${name}CallBack"))
//            .addAnnotation(myCustomAnnotation)
//            .addProperty(
//                PropertySpec.builder("testing",listOfString)
//                    .mutable(false)
//                    .addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("TestingAutoGenerated"))
//                        .build()
//                    )
//                    .initializer(CodeBlock.of(
//                        "mutableListOf<String>()"
//                    ))
//                    .build()
//            )
//            .addFunction(subtractFunction)
//            .build()
//
//        val myEnums = TypeSpec
//            .enumBuilder("EnumFor$name")
//            .addEnumConstant("START", )
//            .addEnumConstant("END", )
//            .addEnumConstant("INITIAL", )
//            .build()
//
//        val fs = FileSpec.builder(packageName, "ExtensionSame")
//            .addImport(EnumTest::class, "")
//            .build()
//
//
//        outputStream.write(
//            """$fs
//                |$autoAnnotation
//                |${entireClass}
//                |${entireInterface}
//                |$myEnums
//            """.trimMargin().toByteArray()
//        )
//        outputStream.flush()
//        outputStream.close()
//    }
//}